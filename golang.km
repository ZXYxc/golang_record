{
    "root": {
        "data": {
            "id": "d19hskhxlt40",
            "created": 1715702545684,
            "text": "golang"
        },
        "children": [
            {
                "data": {
                    "id": "d19hsn8y6uw0",
                    "created": 1715702551671,
                    "text": "channel"
                },
                "children": [
                    {
                        "data": {
                            "id": "d1dslrv5j4w0",
                            "created": 1716139285207,
                            "text": "创建channel实际上就是在内存中实例化了一个hchan结构体，并返回一个chan指针",
                            "note": "```go\ntype hchan struct {\n    qcount   uint           // channel中的元素个数\n    dataqsiz uint           // channel中循环队列的长度\n    buf      unsafe.Pointer // channel缓冲区数据指针\n    elemsize uint16            // buffer中每个元素的大小\n    closed   uint32            // channel是否已经关闭，0未关闭\n    elemtype *_type // channel中的元素的类型\n    sendx    uint   // channel发送操作处理到的位置\n    recvx    uint   // channel接收操作处理到的位置\n    recvq    waitq  // 等待接收的sudog（sudog为封装了goroutine和数据的结构）队列由于缓冲区空间不足而阻塞的Goroutine列表\n    sendq    waitq  // 等待发送的sudogo队列，由于缓冲区空间不足而阻塞的Goroutine列表\n\n    lock mutex   // 一个轻量级锁\n}\n\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d1dsmo9qzfs0",
                            "created": 1716139355747,
                            "text": "朝channel发送数据"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1dsn1sh8ts0",
                                    "created": 1716139385178,
                                    "text": "检查 recvq 是否为空，如果不为空，则从 recvq 头部取一个 goroutine，将数据发送过去，并唤醒对应的 goroutine 即可"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1dsnwmij8o0",
                                    "created": 1716139452297,
                                    "text": "如果 recvq 为空，则将数据放入到 buffer 中"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1dso4uqkuo0",
                                    "created": 1716139470209,
                                    "text": "如果 buffer 已满，则将要发送的数据和当前 goroutine 打包成 sudog 对象放入到 sendq中，并将当前 goroutine 置为 waiting 状态"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d1dsodq617s0",
                            "created": 1716139489523,
                            "text": "接受数据"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1dsomkuf8w0",
                                    "created": 1716139508793,
                                    "text": "检查sendq是否为空，如果不为空，且没有缓冲区，则从sendq头部取一个goroutine，将数据读取出来，并唤醒对应的goroutine，结束读取过程"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1dsp1fj8680",
                                    "created": 1716139541123,
                                    "text": "如果sendq不为空，且有缓冲区，则说明缓冲区已满，则从缓冲区中首部读出数据，把sendq头部的goroutine数据写入缓冲区尾部，并将goroutine唤醒，结束读取过程。",
                                    "layout_right_offset": {
                                        "x": 48,
                                        "y": 0
                                    }
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1dspb6y8eo0",
                                    "created": 1716139562372,
                                    "text": "如果sendq为空，缓冲区有数据，则直接从缓冲区读取数据，结束读取过程"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1dspgrrt9s0",
                                    "created": 1716139574515,
                                    "text": "如果sendq为空，且缓冲区没数据，则只能将当前的goroutine加入到recvq,并进入waiting状态，等待被写goroutine唤醒"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "d19iqeju3mg0",
                    "created": 1715705197120,
                    "text": "context"
                },
                "children": [
                    {
                        "data": {
                            "id": "d1iwss0lktk0",
                            "created": 1716658918309,
                            "text": "于当请求超时或者取消时候，相关的goroutine马上退出释放资源"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d1iwswiv2hs0",
                            "created": 1716658928120,
                            "text": "其可以在多个goroutine或者多个处理函数之间传递共享的信息"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d1iwxu2maow0",
                            "created": 1716659314605,
                            "text": "创建一个新的context，必须基于一个父context，新的context又可以作为其他context的父context。所有context在一起构造成一个context树。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "d19iqpyj48o0",
                    "created": 1715705221953,
                    "text": "协程"
                },
                "children": [
                    {
                        "data": {
                            "id": "d19iwku99dk0",
                            "created": 1715705680996,
                            "text": "优点"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d19ix0qmrug0",
                                    "created": 1715705715605,
                                    "text": "协程在IO多路复用场景"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d19izwpjt9c0",
                                            "created": 1715705941925,
                                            "text": "阻塞式IO"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d19izvnqkm80",
                                    "created": 1715705939639,
                                    "text": "topic"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "d19iwjs3p940",
                    "created": 1715705678689,
                    "text": "互斥锁和读写锁"
                },
                "children": [
                    {
                        "data": {
                            "id": "d1dsexcc9d40",
                            "created": 1716138748581,
                            "text": "互斥锁：Mutex"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1dsg2yn6mw0",
                                    "created": 1716138839178,
                                    "text": "是为了来保护一个资源不会因为并发操作而引起冲突导致数据不准确"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d1dsf4um13c0",
                            "created": 1716138764924,
                            "text": "读写锁：RWMutex（更高效，写操作少，读操作多的场景，底层仍是互斥锁）"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1dshf2z3rc0",
                                    "created": 1716138943926,
                                    "text": "读锁需要阻塞写锁"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1dshjs3o9s0",
                                    "created": 1716138954152,
                                    "text": "读锁不阻塞读锁"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1dsj4wyzh40",
                                    "created": 1716139078523,
                                    "text": "写锁需要阻塞读锁"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "d1dtmdf9xgw0",
                    "created": 1716142153246,
                    "text": "内存逃逸"
                },
                "children": [
                    {
                        "data": {
                            "id": "d1dtmgvn8000",
                            "created": 1716142160767,
                            "text": "go build -gcflags=-m main.go"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d1dtncwotko0",
                            "created": 1716142230487,
                            "text": "golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d1dtnsubaig0",
                            "created": 1716142265172,
                            "text": "典型场景"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1dtnumentc0",
                                    "created": 1716142269048,
                                    "text": "在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1dto602jjc0",
                                    "created": 1716142293818,
                                    "text": "发送指针或带有指针的值到 channel 中。 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1dtoto5kio0",
                                    "created": 1716142345340,
                                    "text": "slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。",
                                    "note": " slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1du4nawziw0",
                                    "created": 1716143585306,
                                    "text": "在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "d1irob64qbk0",
                    "created": 1716644462632,
                    "text": "GMP "
                },
                "children": [
                    {
                        "data": {
                            "id": "d1irodjlpx40",
                            "created": 1716644467800,
                            "text": "什么时候回发生抢占"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1irokfn5a80",
                                    "created": 1716644482798,
                                    "text": "当goroutine因为channel操作或者network I/O而阻塞时"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d1irp7hsj6g0",
                                            "created": 1716644532994,
                                            "text": "此时M不会阻塞，M会继续寻找其他可运行的G"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d1iwqohtuzk0",
                                            "created": 1716658753915,
                                            "text": "当阻塞的G恢复之后，重新进入P的队列等待执行"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d1iwkq3ltq00",
                                    "created": 1716658287224,
                                    "text": "当G陷入系统调用"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d1iwlgeo4o00",
                                            "created": 1716658344489,
                                            "text": "此时G会阻塞在_Gsyscall状态，M也处于 block on syscall 状态"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d1iwlru1xj40",
                                            "created": 1716658369364,
                                            "text": "此时的M可被抢占调度：执行该G的M会与P解绑，而P则尝试与其它idle的M绑定，继续执行其它G"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d1iwlwzwopc0",
                                            "created": 1716658380602,
                                            "text": "如果没有其它idle的M，但P的Local队列中仍然有G需要执行，则创建一个新的M；"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d1iwm4dfdc00",
                                            "created": 1716658396657,
                                            "text": "当系统调用完成后，G会重新尝试获取一个idle的P进入它的Local队列恢复执行，"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d1iwm8nup680",
                                            "created": 1716658405994,
                                            "text": "如果没有idle的P，G会被标记为runnable加入到Global队列"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d1iwn12vz280",
                            "created": 1716658467854,
                            "text": "what"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1iwn23mi2g0",
                                    "created": 1716658470075,
                                    "text": "G是goroutine，是golang实现的协程，M是OS线程，P是逻辑处理器"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d1iwonsbqq00",
                            "created": 1716658595645,
                            "text": "M"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1iwops89rs0",
                                    "created": 1716658599993,
                                    "text": "M获取可运行G流程是先从P的本地队列获取，若未获取到，则从其他P偷取过来（即work steal)，若其他的P也没有则从全局G队列获取，若都未获取到，则M将处于自旋状态，并不会销毁。"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "d1ix63a4pb40",
                    "created": 1716659961564,
                    "text": "defer"
                },
                "children": [
                    {
                        "data": {
                            "id": "d1ix6cjufbk0",
                            "created": 1716659981742,
                            "text": "defer函数的传入参数在定义时就已经明确"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d1ix6jdscfc0",
                            "created": 1716659996614,
                            "text": "defer函数是按照后进先出的顺序执行"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d1ix7522oqo0",
                            "created": 1716660043795,
                            "text": "defer函数可以读取和修改函数的命名返回值"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d1ix7tbqimg0",
                            "created": 1716660096622,
                            "text": "defer函数会构建成一个_defer链表，后面加入的defer函数会插入链表的头部，该链表链表头部会链接到G上"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d1km5tdx7go0",
                            "created": 1716832027730,
                            "text": "return之后的语句先执行，defer后的语句后执行，最后再执行函数返回"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d1km8mu6d340",
                            "created": 1716832248568,
                            "text": "遇到panic时，遍历本协程的defer链表，并执行defer"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1km8va3vsg0",
                                    "created": 1716832266945,
                                    "text": "遇到recover则停止panic，返回recover处继续往下执行"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1km8zgrttc0",
                                    "created": 1716832276055,
                                    "text": "如果没有遇到recover，遍历完本协程的defer链表后，向stderr抛出panic信息"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1km9sb9t0g0",
                                    "created": 1716832338849,
                                    "text": "panic仅有最后一个可以被revover捕获，有多个panic会覆盖只有最后的一个panic"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d1kmb9x7dl40",
                            "created": 1716832455545,
                            "text": " defer下的函数参数包含子函数，需要连同函数地址、函数形参一同进栈，会先执行子函数"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "d1keo9gef680",
                    "created": 1716810904384,
                    "text": "Map",
                    "expandState": "expand"
                },
                "children": [
                    {
                        "data": {
                            "id": "d1keobpd9e00",
                            "created": 1716810909281,
                            "text": "Go语言解决hash冲突不是链表，实际主要用的数组(内存上的连续空间)",
                            "image": "http://blog-1251019962.cos.ap-beijing.myqcloud.com/qiniu_img_2022/20201217165551.png",
                            "imageTitle": "",
                            "imageSize": {
                                "width": 195,
                                "height": 200
                            },
                            "hyperlink": null,
                            "hyperlinkTitle": null,
                            "expandState": "collapse"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1kf2ur4d0w0",
                                    "created": 1716812047843,
                                    "text": "读取过程",
                                    "expandState": "expand",
                                    "image": "https://img.draveness.me/2020-10-18-16030322432560/hashmap-mapaccess.png",
                                    "imageTitle": "",
                                    "imageSize": {
                                        "width": 0,
                                        "height": 0
                                    }
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d1kepzax1gw0",
                                            "created": 1716811039013,
                                            "text": "它会先比较哈希的高 8 位和桶中存储的 tophash，再比较传入的和桶中的值以加速数据的读写。"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d1kf1mrotjs0",
                                                    "created": 1716811952099,
                                                    "text": "用于选择桶序号的是哈希的最低几位，而用于加速访问的是哈希的高 8 位"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d1kepupzltc0",
                                            "created": 1716811029040,
                                            "text": " ",
                                            "expandState": "expand"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d1kezh5s7eg0",
                                                    "created": 1716811783162,
                                                    "text": "bmap",
                                                    "note": "字段\t解释\ntopbits\t长度为8的数组，[]uint8，元素为：key获取的hash的高8位，遍历时对比使用，提高性能。如下图所示\nkeys\t长度为8的数组，[]keytype，元素为：具体的key值。如下图所示\nelems\t长度为8的数组，[]elemtype，元素为：键值对的key对应的值。如下图所示\noverflow\t指向的hmap.extra.overflow溢出桶里的bmap，上面的字段topbits、keys、elems长度为8，最多存8组键值对，存满了就往指向的这个bmap里存\npad\t对齐内存使用的，不是每个bmap都有会这个字段，需要满足一定条件",
                                                    "expandState": "expand"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d1keytztsq00",
                                                            "created": 1716811732736,
                                                            "text": "每个bmap结构最多存放8组键值对"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d1kf54etwew0",
                                            "created": 1716812225596,
                                            "text": "如果tophash[i]和哈希的高八位相同，就会返回目标位置的地址（inserti = &b.tophash[i]表示目标元素的在桶中的索引）"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d1kf8zk2l0g0",
                                            "created": 1716812528485,
                                            "text": "遍历的key： insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d1kf94ca1340",
                                            "created": 1716812538898,
                                            "text": "遍历的value：add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d1kfbly7hn40",
                                    "created": 1716812733958,
                                    "text": "扩容"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d1kfbnx7hag0",
                                            "created": 1716812738251,
                                            "text": "装载因子已经超过 6.5；"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d1kfbnx7v0o0",
                                            "created": 1716812738251,
                                            "text": "哈希使用了太多溢出桶"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d1kff5g9tug0",
                                            "created": 1716813011501,
                                            "text": "扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动。"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d1kfelka1540",
                                    "created": 1716812968208,
                                    "text": "删除"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d1kfemz8hs00",
                                            "created": 1716812971289,
                                            "text": "delete 关键字在编译期间经过类型检查\n和中间代码生成\n阶段被转换成 runtime.mapdelete\n 函数簇中的一员，用于处理删除逻辑的函数与哈希表的 runtime.mapassign\n 几乎完全相同",
                                            "layout_left_offset": {
                                                "x": -4,
                                                "y": 1
                                            }
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "d1keysryiio0",
                    "created": 1716811730083,
                    "text": "内存策略",
                    "expandState": "expand",
                    "hyperlink": "https://juejin.cn/post/6844903795739082760",
                    "hyperlinkTitle": ""
                },
                "children": [
                    {
                        "data": {
                            "id": "d1kfgfs8dy80",
                            "created": 1716813112357,
                            "text": "Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，没有真的分配内存），切成小块后自己管理。",
                            "image": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/13/169755c860e5fa3c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",
                            "imageTitle": "",
                            "imageSize": {
                                "width": 200,
                                "height": 43
                            }
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d1kfixe0rrs0",
                                    "created": 1716813307408,
                                    "text": "arena区域就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成8KB大小的页，一些页组合起来称为mspan"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1kfj8glxko0",
                                    "created": 1716813331509,
                                    "text": "bitmap区域标识arena区域哪些地址保存了对象，并且用4bit标志位表示对象是否包含指针、GC标记信息。",
                                    "layout_left_offset": {
                                        "x": -15,
                                        "y": 9
                                    },
                                    "image": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/13/169755c75a5cd188~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp",
                                    "imageTitle": "",
                                    "imageSize": {
                                        "width": 0,
                                        "height": 0
                                    }
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d1kfkkdsfnk0",
                                    "created": 1716813435824,
                                    "text": "spans区域存放mspan（也就是一些arena分割的页组合起来的内存管理基本单元）的指针，每个指针对应一页",
                                    "layout_left_offset": {
                                        "x": -47,
                                        "y": 0
                                    }
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d1kfkuklz2g0",
                                            "created": 1716813458004,
                                            "text": "mspan：Go中内存管理的基本单元，是由一片连续的8KB的是一个包含起始地址、mspan规格、页的数量等内容的双端链表。",
                                            "layout_left_offset": {
                                                "x": -82,
                                                "y": 0
                                            },
                                            "note": "每个mspan按照它自身的属性Size Class的大小分割成若干个object，每个object可存储一个对象。并且会使用一个位图来标记其尚未使用的object。属性Size Class决定object大小，而mspan只会分配给和object尺寸大小接近的对象，当然，对象的大小要小于object大小。还有一个概念：Span Class，它和Size Class的含义差不多。\n\n这是因为其实每个 Size Class有两个mspan，也就是有两个Span Class。其中一个分配给含有指针的对象，另一个分配给不含有指针的对象。这会给垃圾回收机制带来利好，之后的文章再谈。\n\n如下图，mspan由一组连续的页组成，按照一定大小划分成object。"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "template": "default",
    "theme": "fresh-blue",
    "version": "1.4.43"
}